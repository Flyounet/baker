#!/bin/bash

#
# config
#
config() {
	echo "Reading Configuration..." >&2
	if [ -f "${1:-}" ]; then
		. "${1}"
	fi
	# POST_DIR stores all post markdown files
	export POST_DIR="${POST_DIR:=post}"

	# OUTPUT_DIR stores all compiled html
	export OUTPUT_DIR="${OUTPUT_DIR:=out}"

	# DRAFT_DIR stores all compiled html
	export DRAFT_DIR="${DRAFT_DIR:=draft}"

	# LAYOUT_DIR stores all layout markdown files
	export LAYOUT_DIR="${LAYOUT_DIR:=layout}"

	# PUBLIC_DIR stores css and static images
	export PUBLIC_DIR="${PUBLIC_DIR:=public}"

	# site
	export SITE_NAME="${SITE_NAME:=a baker blog}"
	export SITE_DESC="${SITE_DESC:=written in bash}"
	export DISQUS="${DISQUS:=bakerbash}"

	# author
	export AUTHOR_NAME="${AUTHOR_NAME:=baker}"
	export AUTHOR_DESC="${AUTHOR_DESC:=a very-experienced bread baker, who also loves planting trees.}"
	export AUTHOR_EMAIL="${AUTHOR_EMAIL:=email@example.org}"
	export AUTHOR_EMAIL_HASH="${AUTHOR_EMAIL_HASH:=$(md5sum <<< "$AUTHOR_NAME" | awk '{ print $1 }')}"
	export AUTHOR_TWITTER="${AUTHOR_TWITTER:=twitter}"
	export AUTHOR_GITHUB="${AUTHOR_GITHUB:=github}"
}

#
# helper
#

# absolute dir path of this script
readonly SCRIPT_DIR="$(dirname "$(readlink -f "$0")")"

# variable identifier definition
readonly VAR_ID='[A-Za-z_]+'

# headers prints the header of a markdown file
headers() {
	awk '/^---$/ { c++; next } c == 1'
}

# header prints a specific header value
header() {
	headers | grep "^$1: " | cut -d ' ' -f 2-
}

# body prints the body of a markdown file
body() {
	awk '/^---$/ { c++; next } c >= 2'
}

# slug creates a friendly URL like 'hello-world'
slug() {
	iconv -f utf8 -t ascii//TRANSLIT | tr -cs '[:alnum:]\n' - | tr '[:upper:]' '[:lower:]' | sed 's|^-*||;s|-*$||'
}

#
# template
#

# first_block gets the first block location
first_block() {
	local c
	local tag
	local start
	local lines
	local i
	readarray -t lines

	# counter is used to find the matching @end
	for (( i=0; i < ${#lines[@]}; i++ )); do
		case "${lines[i]}" in
		@if*)
			if (( c == 0 )); then
				tag=if
				start=$((i+1))
			fi
			(( c++ ))
			;;
		@each*)
			if (( c == 0 )); then
				tag=each
				start=$((i+1))
			fi
			(( c++ ))
			;;
		@cmd)
			if (( c == 0 )); then
				tag=cmd
				start=$((i+1))
			fi
			(( c++ ))
			;;
		@end)
			# @end is found before any starting tag
			(( c == 0 )) && return 1
			(( c-- ))
			if (( c == 0)); then
				# the matching @end is found, print `tag:start:end`
				echo "$tag:$start:$((i+1))"
				return 0
			fi
			;;
		esac
	done
}

# find_submatch prints all occurrences of the first submatch
find_submatch() {
	local s="$1"
	while [[ "$s" =~ $2 ]]; do
		echo "${BASH_REMATCH[1]}"
		s="${s#*${BASH_REMATCH[0]}}"
	done
}

# render_inline handles @include, and evaluates variables
render_inline() {
	local lines
	local line
	local matches
	local match
	readarray -t lines
	for line in "${lines[@]}"; do
		if [[ "$line" =~ ^@include\ ($VAR_ID)$ ]]; then
			# @include renders partial
			render_file "$LAYOUT_DIR/${BASH_REMATCH[1]}.md"
		else
			# evaluate variables
			readarray -t matches < <(find_submatch "$line" "\{\{ ($VAR_ID) \}\}")
			for match in "${matches[@]}"; do
				line="${line//"{{ $match }}"/${!match}}"
			done

			echo "$line"
		fi
	done
}

# render_if handles @if
render_if() {
	local lines
	local line
	readarray -t lines
	[[ "${lines[0]}" =~ ^@if\ ('!')?($VAR_ID)$ ]] || return 1

	# skip render on undefined_var or !defined_var
	if [[ "${!BASH_REMATCH[2]}" ]]; then
		[[ "${BASH_REMATCH[1]}" == '!' ]] && return 0
	else
		[[ "${BASH_REMATCH[1]}" == '!' ]] || return 0
	fi

	# recursively render the inner block
	for line in "${lines[@]:1:${#lines[@]}-2}"; do
		echo "$line"
	done | render
}

# render_each handles @each
render_each() {
	local lines
	local line
	local idx
	local array
	local vars
	local var
	readarray -t lines
	[[ "${lines[0]}" =~ ^@each\ ($VAR_ID)$ ]] || return 1
	for (( idx=0; ; idx++ )); do
		array="${BASH_REMATCH[1]}_${idx}_"
		readarray -t vars < <(compgen -v | grep "^$array")
		(( ${#vars[@]} == 0 )) && break

		# define element in the loop context
		for var in "${vars[@]}"; do
			declare "${var#$array}"="${!var}"
		done

		# recursively render the inner block
		for line in "${lines[@]:1:${#lines[@]}-2}"; do
			echo "$line"
		done | render
	done
}

# render_cmd handles @cmd
render_cmd() {
	source <(sed '1d; $d')
}

# render handles general template from stdin
render() {
	local input="$(< /dev/stdin)"
	local tag
	local start
	local end

	IFS=: read -r tag start end < <(first_block <<< "$input")
	if [[ "$tag" ]]; then
		# render inline before the first block
		(( start > 1 )) && sed "1,$((start-1))!d" <<< "$input" | render_inline

		# handle first block
		case "$tag" in
		if)
			render_if
			;;
		each)
			render_each
			;;
		cmd)
			render_cmd
			;;
		esac < <(sed "$start,$end!d" <<< "$input")

		# recursively handle the rest of the template
		sed "$((end+1)),\$!d" <<< "$input" | render
	else
		# if the first block is not found, just render inline
		render_inline <<< "$input"
	fi
}

# render_file_case uses markdown for posts, and uses render for templates
render_file_case() {
	case "$1" in
	"$POST_DIR"/*)
		"$SCRIPT_DIR/Markdown.pl"
		;;
	"$LAYOUT_DIR"/*)
		render
		;;
	esac < <(body < "$1")
}

# export_headers reads markdown file headers
export_headers() {
	local vars
	local var
	readarray -t vars < <(headers < "$1" | cut -d : -f 1)
	for var in "${vars[@]}"; do
		# by default, declare is local
		declare -g "$2$var"="$(header "$var" < "$1")"
	done
}

# render_file renders a specific file (with its parent layout) recursively
render_file() {
	local content
	local f="$1"
	while [[ -f "$f" ]]; do
		export_headers "$f" ''
		content="$(render_file_case "$f")"

		f="$LAYOUT_DIR/$(header layout < "$f").md"
	done
	echo "$content"
}

# post_toggle toggles the status of a post (either use ID or post name)
post_toggle() {
	local _fname=''
	if [ -z "${1:-}" ]; then
		usage
	elif [ -z "${1//[0-9]/}" ]; then
		readarray -t posts < <(find "$POST_DIR" -name '*.md' | sort -r)
		if [ ${1} -lt ${#posts[@]} ]; then
			_fname="${posts[${1}]}"
		fi
	elif [ -f "${POST_DIR}/${1}" -o -f "${POST_DIR}/${1}.md" ]; then
		_fname="${POST_DIR}/${1//\.md/}.md"
	fi
	if [ -z "${_fname}" ]; then
		echo "This post doesn't exist"
		exit 1
	fi
	if [ "$(header draft < "${_fname}")" == 'false' ]; then
		sed -i -e 's;^[[:space:]]*draft:[[:space:]]*false[[:space:]]*$;draft: true;g'  "${_fname}"
	else
		sed -i -e 's;^[[:space:]]*draft:[[:space:]]*.*[[:space:]]*$;draft: false;g'  "${_fname}"
	fi
}

# post_list list the id title and status of posts
post_list() {
	local idx=0
	readarray -t posts < <(find "$POST_DIR" -name '*.md' | sort -r)
	(
		echo "id title status"
		for post in "${posts[@]}"; do
			id="$(basename "$post" .md)"
			# skip drafts
			if [ "$(header draft < "$post")" == 'false' ]; then
				echo "${idx} $id [Published]"
			else
				echo "${idx} $id [Draft]"
			fi
			((idx++))
		done
	) | column -t
}

# post_post creates a post (in the POST_DIR) with the minimum information 
post_post() {
	readonly title="${@}"
	[[ "$title" ]] || usage

	mkdir -p "$POST_DIR" || ( echo "Can't create '$POST_DIR'" >&2; exit 1 )
	readonly post_file="$POST_DIR/$(date +%Y-%m-%d)-$(slug <<< "$title").md"
	cat > "$post_file" <<-EOF
	---
	title: $title
	date: $(date -u +%FT%TZ)
	layout: post
	draft: true
	summary:
	---
	EOF

	echo "$post_file"
	[[ "$EDITOR" ]] && $EDITOR "$post_file"
}

# post_bake it's where the magic start
post_bake() {
	rm -rf "$DRAFT_DIR"
	mkdir -p "$DRAFT_DIR"
	rm -rf "$OUTPUT_DIR"
	mkdir -p "$OUTPUT_DIR"

	[[ -d "$POST_DIR" ]] || usage
	[[ -d "$PUBLIC_DIR" ]] && cp -r "$PUBLIC_DIR"/. "$OUTPUT_DIR"
	[[ -d "$PUBLIC_DIR" ]] && cp -r "$PUBLIC_DIR"/. "$DRAFT_DIR"
	touch "$DRAFT_DIR/index.html"

	readarray -t posts < <(find "$POST_DIR" -name '*.md' | sort -r)
	echo "Rendering Posts..." >&2
	idx=0
	id_all=0
	time for post in "${posts[@]}"; do
		idx_prev=1;idx_next=1
		id="$(basename "$post" .md)"
		# skip drafts
		if [ "$(header draft < "$post")" != false ]; then
			(( id_all++ ))
			POST_PREV='index.html';POST_NEXT='index.html'; render_file "$post" > "$DRAFT_DIR/$id.html"; continue;
		fi
		if [ ${idx} -eq 0 ]; then # It's the first post, so the newer one is index
			id_prev=0
		else # search for the previous post not draft
			while [ -f "${posts[$((id_all-idx_prev))]}" -a "$(header draft < "${posts[$((id_all-idx_prev))]}" 2>/dev/null)" != false ]; do
				(( idx_prev++ ))
				if [Â ${idx_prev} -gt ${id_all} ]; then idx_prev=${id_all}; break; fi
			done 2>/dev/null
		fi
		# look for the next older post not draft
		while [ -f "${posts[$((id_all+idx_next))]}" -a "$(header draft < "${posts[$((id_all+idx_next))]}" 2>/dev/null)" != false ]; do
			(( idx_next++ ))
		done 2>/dev/null

		if [ ${idx} -eq 0 -o $((idx_all-idx_prev)) -eq 0 -a ${id_all} -eq 0 ]; then
			POST_PREV="index.html"
		else
			POST_PREV="$( basename "${posts[$((id_all-idx_prev))]}" )"
			POST_PREV="${POST_PREV%*.md}.html"
		fi
		POST_NEXT="$( basename "${posts[$((id_all+idx_next))]}" )"
		[[ -z "${POST_PREV:=}" ]] && POST_PREV='index.html'
		[[ -z "${POST_NEXT:=}" ]] && POST_NEXT='index.md'
		echo "$idx - $idx_next - $id [Prev:${POST_PREV}][Next:${POST_NEXT}]"
		POST_NEXT="${POST_NEXT%*.md}.html"

		render_file "$post" > "$OUTPUT_DIR/$id.html" &
		declare "posts_${idx}_id"="$id"
		export_headers "$post" "posts_${idx}_"
		POST_PREV="$id.html"
		(( id_all++ ))
		(( idx++ ))
	done
	echo "Rendering Index..." >&2
	render_file "$LAYOUT_DIR/index.md" > "$OUTPUT_DIR/index.html" &
	wait
}

#
# usage
#
usage() {
	cat <<-EOF
	baker
	  post [title]  draft a post
	  bake          ship all posts
	  list		list all posts with state
	  toggle [post] toggle the draft status of a post
	EOF
	exit 1
}

(( $# == 0 )) && usage

config
readonly POST_DIR; readonly OUTPUT_DIR; readonly DRAFT_DIR; readonly LAYOUT_DIR; readonly PUBLIC_DIR
readonly SITE_NAME; readonly SITE_DESC
readonly AUTHOR_NAME; readonly AUTHOR_DESC; readonly AUTHOR_EMAIL; readonly AUTHOR_EMAIL_HASH;
readonly AUTHOR_TWITTER; readonly AUTHOR_GITHUB; readonly DISQUS

case "$1" in
bake)
	post_bake
	;;
post)
	post_post "${@:2}"
	;;
list)
	post_list
	;;
toggle)
	post_toggle "${@:2}"
	;;
*)
	usage
	;;
esac
