#!/bin/bash

#
# config
#
config() {
	echo "Reading Configuration..." >&2
	[[ "${__w:=./}" != './' ]] && echo "Working dir changed to ${__w}"
	[[ "${__w: -1}" != '/' ]] && __w="${__w//\/\//\/}/"
	# If a config file is given, we take it first, or look for a default config file
	if [ -f "$(readlink -m "${1:-}")" ]; then
		. "${1}"
	elif [ ${__n:=0} -eq 0 -a -f "${__w}${DEFAULT_CONFIG_FILENAME}" ]; then
		. "${__w}${DEFAULT_CONFIG_FILENAME}"
		echo "Default config file loaded ${__w}${DEFAULT_CONFIG_FILENAME}"
	fi
		
	# POST_DIR stores all post markdown files
	export POST_DIR="${POST_DIR:=${__w}post}"

	# OUTPUT_DIR stores all compiled html
	export OUTPUT_DIR="${OUTPUT_DIR:=${__w}out}"

	# DRAFT_DIR stores all compiled html
	export DRAFT_DIR="${DRAFT_DIR:=${__w}draft}"

	# LAYOUT_DIR stores all layout markdown files
	export LAYOUT_DIR="${LAYOUT_DIR:=${__w}layout}"

	# PUBLIC_DIR stores css and static images
	export PUBLIC_DIR="${PUBLIC_DIR:=${__w}public}"

	# site
	export SITE_NAME="${SITE_NAME:=a baker blog}"
	export SITE_DESC="${SITE_DESC:=written in bash}"
	export DISQUS="${DISQUS:=bakerbash}"

	# author
	export AUTHOR_NAME="${AUTHOR_NAME:=baker}"
	export AUTHOR_DESC="${AUTHOR_DESC:=a very-experienced bread baker, who also loves planting trees.}"
	export AUTHOR_EMAIL="${AUTHOR_EMAIL:=email@example.org}"
	export AUTHOR_EMAIL_HASH="${AUTHOR_EMAIL_HASH:=$(md5sum <<< "$AUTHOR_NAME" | awk '{ print $1 }')}"
	export AUTHOR_TWITTER="${AUTHOR_TWITTER:=twitter}"
	export AUTHOR_GITHUB="${AUTHOR_GITHUB:=github}"
	
	# categories
	export TAGS_BASELIST="${TAGS_BASELIST:=mylife,internet,baker}"
	export TAGS_LINK="${TAGS_LINK:=<li><a href='index_==tagNameSlugged==.html' title='jump to tag'><i class='fa fa-tag'></i>&nbsp;==tagName==</a></li>}"

	# RSS
	export RSS_SITE_URL="${RSS_SITE_URL:=http://baker.example.com/alone}"
}

#
# helper
#

# default filename for Baker config file (just the filename no path)
readonly DEFAULT_CONFIG_FILENAME="${DEFAULT_CONFIG_FILENAME:=baker.conf}"

# absolute dir path of this script
readonly SCRIPT_DIR="$(dirname "$(readlink -f "$0")")"

# variable identifier definition
readonly VAR_ID='[A-Za-z_]+'

# headers prints the header of a markdown file
headers() {
	awk '/^---$/ { c++; next } c == 1'
}

# header prints a specific header value
header() {
	headers | grep "^$1: " | cut -d ' ' -f 2-
}

# body prints the body of a markdown file
body() {
	awk '/^---$/ { c++; next } c >= 2'
}

# slug creates a friendly URL like 'hello-world'
slug() {
	iconv -f utf8 -t ascii//TRANSLIT | tr -cs '[:alnum:]\n' - | tr '[:upper:]' '[:lower:]' | sed 's|^-*||;s|-*$||'
}

#
# template
#

# first_block gets the first block location
first_block() {
	local c
	local tag
	local start
	local lines
	local i
	readarray -t lines

	# counter is used to find the matching @end
	for (( i=0; i < ${#lines[@]}; i++ )); do
		case "${lines[i]}" in
		@if*)
			if (( c == 0 )); then
				tag=if
				start=$((i+1))
			fi
			(( c++ ))
			;;
		@each*)
			if (( c == 0 )); then
				tag=each
				start=$((i+1))
			fi
			(( c++ ))
			;;
		@cmd)
			if (( c == 0 )); then
				tag=cmd
				start=$((i+1))
			fi
			(( c++ ))
			;;
		@end)
			# @end is found before any starting tag
			(( c == 0 )) && return 1
			(( c-- ))
			if (( c == 0)); then
				# the matching @end is found, print `tag:start:end`
				echo "$tag:$start:$((i+1))"
				return 0
			fi
			;;
		esac
	done
}

# find_submatch prints all occurrences of the first submatch
find_submatch() {
	local s="$1"
	while [[ "$s" =~ $2 ]]; do
		echo "${BASH_REMATCH[1]}"
		s="${s#*${BASH_REMATCH[0]}}"
	done
}

# render_inline handles @include, and evaluates variables
render_inline() {
	local lines
	local line
	local matches
	local match
	readarray -t lines
	for line in "${lines[@]}"; do
		if [[ "$line" =~ ^@include\ ($VAR_ID)$ ]]; then
			# @include renders partial
			render_file "$LAYOUT_DIR/${BASH_REMATCH[1]}.md"
		else
			# evaluate variables
			readarray -t matches < <(find_submatch "$line" "\{\{ ($VAR_ID) \}\}")
			for match in "${matches[@]}"; do
				line="${line//"{{ $match }}"/${!match}}"
			done

			echo "$line"
		fi
	done
}

# render_if handles @if
render_if() {
	local lines
	local line
	readarray -t lines
	# The following regexp should be a little amended to allow more than one space|tab
	# between the @if and id (AND after)
	[[ "${lines[0]}" =~ ^@if\ ('!')?($VAR_ID)$ ]] || return 1

	# skip render on undefined_var or !defined_var
	if [[ "${!BASH_REMATCH[2]}" ]]; then
		[[ "${BASH_REMATCH[1]}" == '!' ]] && return 0
	else
		[[ "${BASH_REMATCH[1]}" == '!' ]] || return 0
	fi
	# recursively render the inner block
	for line in "${lines[@]:1:${#lines[@]}-2}"; do
		echo "$line"
	done | render
}

# render_each handles @each
render_each() {
	local lines
	local line
	local idx
	local array
	local vars
	local var
	readarray -t lines
	[[ "${lines[0]}" =~ ^@each\ ($VAR_ID)$ ]] || return 1
	for (( idx=0; ; idx++ )); do
		array="${BASH_REMATCH[1]}_${idx}_"
		readarray -t vars < <(compgen -v | grep "^$array")
		(( ${#vars[@]} == 0 )) && break

		# define element in the loop context
		for var in "${vars[@]}"; do
			declare "${var#$array}"="${!var}"
		done

		# recursively render the inner block
		for line in "${lines[@]:1:${#lines[@]}-2}"; do
			echo "$line"
		done | render
	done
}

# render_cmd handles @cmd
render_cmd() {
	source <(sed '1d; $d')
}

# render handles general template from stdin
render() {
	local input="$(< /dev/stdin)"
	local tag
	local start
	local end

	IFS=: read -r tag start end < <(first_block <<< "$input")
	if [[ "$tag" ]]; then
		# render inline before the first block
		(( start > 1 )) && sed "1,$((start-1))!d" <<< "$input" | render_inline

		# handle first block
		case "$tag" in
		if)
			render_if
			;;
		each)
			render_each
			;;
		cmd)
			render_cmd
			;;
		esac < <(sed "$start,$end!d" <<< "$input")

		# recursively handle the rest of the template
		sed "$((end+1)),\$!d" <<< "$input" | render
	else
		# if the first block is not found, just render inline
		render_inline <<< "$input"
	fi
}

# render_file_case uses markdown for posts, and uses render for templates
render_file_case() {
	case "$1" in
	"$POST_DIR"/*)
		"$SCRIPT_DIR/Markdown.pl"
		;;
	"$LAYOUT_DIR"/*)
		render
		;;
	esac < <(body < "$1")
}

# export_headers reads markdown file headers
export_headers() {
	local vars
	local var
	readarray -t vars < <(headers < "$1" | cut -d : -f 1)
	for var in "${vars[@]}"; do
		# by default, declare is local
		declare -g "$2$var"="$(header "$var" < "$1")"
	done
}

# render_file renders a specific file (with its parent layout) recursively
render_file() {
	local content
	local f="$1"
	while [[ -f "$f" ]]; do
		export_headers "$f" ''
		content="$(render_file_case "$f")"

		f="$LAYOUT_DIR/$(header layout < "$f").md"
	done
	echo "$content"
}

# post_date change the date of a post and the name (unless a future -D is used)
post_date() {
	local _fname=''
	readarray -t posts < <(find "$POST_DIR" -name '*.md' | sort -r)
	if [ -z "${1:-}" ]; then
		usage
	elif [ -z "${1//[0-9]/}" ]; then
		if [ ${1} -lt ${#posts[@]} ]; then
			_fname="${posts[${1}]}"
		fi
	elif [ -f "${POST_DIR}/${1}" -o -f "${POST_DIR}/${1}.md" ]; then
		_fname="${POST_DIR}/${1//\.md/}.md"
	fi
	if [ -z "${_fname}" ]; then
		die "This post doesn't exist"
	fi
	_pDate="$(header date < "${_fname}")"
	echo "For post ${_fname}, date has been set to : ${_pDate}"
	read -i "${_PDate}" -p "Please, enter the new date/time for your post: " _nDate
	[[ -z "${_nDate}" ]] && die "You wanted to set an empty date. Aborting..."
	_nDate="$(date -u "+%FT%TZ" --date "${_nDate}" 2>/dev/null)"
	if [ ${?} -ne 0 ]; then
		die "Date invalide."
	else
		sed -i -e 's;^[[:space:]]*date:[[:space:]]*.*$;date: '"${_nDate}"';g'  "${_fname}"
	fi
	if [ ${__D:=0} -eq 0 ]; then
		mv "${_fname}" "${POST_DIR}/$(sed -e 's;^\([0-9]\{4\}\(-[0-9]\{2\}\)\{2\}-\);'"$(date "+%Y-%m-%d" --date "${_nDate}")"'-;g' <<< "${_fname##*/}")"
	fi
}

# post_rename parse the headers post to rename the post (usefull if changed the title or the date)
post_rename() {
	local _fname=''
	readarray -t posts < <(find "$POST_DIR" -name '*.md' | sort -r)
	if [ -z "${1:-}" ]; then
		usage
	elif [ -z "${1//[0-9]/}" ]; then
		[[ ${1} -lt ${#posts[@]} ]] && _fname="${posts[${1}]}"
	elif [ -f "${POST_DIR}/${1}" -o -f "${POST_DIR}/${1}.md" ]; then
		_fname="${POST_DIR}/${1//\.md/}.md"
	fi
	[[ -z "${_fname}" ]] && die "This post doesn't exist"
	_pDate="$(header date < "${_fname}")"
	_pTitle="$(header title < "${_fname}")"
	_nDate="$(date -u "+%FT%TZ" --date "${_pDate}" 2>/dev/null)"
	[[ ${?} -ne 0 ]] && die "Date invalide."
	mv "${_fname}" "${POST_DIR}/$(date -u +%Y-%m-%d --date "${_nDate}")-$(slug <<< "${_pTitle}").md" && \
		echo "${POST_DIR}/$(date -u +%Y-%m-%d --date "${_nDate}")-$(slug <<< "${_pTitle}").md"
}

# post_toggle toggles the status of a post (either use ID or post name)
post_toggle() {
	local _fname=''
	if [ -z "${1:-}" ]; then
		usage
	elif [ -z "${1//[0-9]/}" ]; then
		readarray -t posts < <(find "$POST_DIR" -name '*.md' | sort -r)
		[[ ${1} -lt ${#posts[@]} ]] && _fname="${posts[${1}]}"
	elif [ -f "${POST_DIR}/${1}" -o -f "${POST_DIR}/${1}.md" ]; then
		_fname="${POST_DIR}/${1//\.md/}.md"
	fi
	[[ -z "${_fname}" ]] && die "This post doesn't exist"
	if [ "$(header draft < "${_fname}")" == 'false' ]; then
		sed -i -e 's;^[[:space:]]*draft:[[:space:]]*false[[:space:]]*$;draft: true;g'  "${_fname}"
	else
		sed -i -e 's;^[[:space:]]*draft:[[:space:]]*.*[[:space:]]*$;draft: false;g'  "${_fname}"
	fi
}

# post_list list the id title and status of posts
post_list() {
	local idx=0
	[[ ! -d "${POST_DIR}" ]] && die "${POST_DIR} doesn't exit. Aborting..."
	readarray -t posts < <(find "$POST_DIR" -name '*.md' | sort -r)
	(
		echo "id title status tag(s)"
		for post in "${posts[@]}"; do
			id="$(basename "$post" .md)"
			# skip drafts
			if [ "$(header draft < "$post")" == 'false' ]; then
				echo "${idx} $id [Published] [$(header tags < "$post")]"
			else
				echo "${idx} $id [Draft] [$(header tags < "$post")]"
			fi
			((idx++))
		done
	) | column -t
}

# post_post creates a post (in the POST_DIR) with the minimum information 
post_post() {
	readonly title="${@}"
	[[ "$title" ]] || usage

	mkdir -p "$POST_DIR" || die "Can't create '$POST_DIR'"
	readonly post_file="$POST_DIR/$(date +%Y-%m-%d)-$(slug <<< "$title").md"
	cat > "$post_file" <<-EOF
	---
	title: $title
	date: $(date -u +%FT%TZ)
	tags: ${TAGS_BASELIST}
	layout: post
	draft: true
	summary:
	---
	EOF

	echo "$post_file"
	[[ "$EDITOR" ]] && $EDITOR "$post_file"
}

# post_bake it's where the magic start
post_bake() {
	rm -rf "$DRAFT_DIR" "$OUTPUT_DIR"
	mkdir -p "$DRAFT_DIR" "$OUTPUT_DIR"

	[[ -d "$POST_DIR" ]] || usage
	[[ -d "$PUBLIC_DIR" ]] && cp -r "$PUBLIC_DIR"/. "$OUTPUT_DIR"
	[[ -d "$PUBLIC_DIR" ]] && cp -r "$PUBLIC_DIR"/. "$DRAFT_DIR"
	touch "$DRAFT_DIR/index.html"

	readarray -t posts < <(find "$POST_DIR" -name '*.md' | sort -r)
	echo "Rendering Posts..." >&2
	idx=0
	id_all=0
	_allTags=''
	time for post in "${posts[@]}"; do
		[[ ${id_all} -eq 0 ]] && echo -e "id\t- Title\t[Tags]"
		idx_prev=1;idx_next=1
		id="$(basename "$post" .md)"
		# skip drafts
		if [ "$(header draft < "$post")" != false ]; then
			(( id_all++ ))
			POST_PREV='index.html';POST_NEXT='index.html'; render_file "$post" > "$DRAFT_DIR/$id.html"; continue;
		fi
		if [ ${idx} -eq 0 ]; then # It's the first post, so the newer one is index
			id_prev=0
		else # search for the previous post not draft
			while [ -f "${posts[$((id_all-idx_prev))]}" -a "$(header draft < "${posts[$((id_all-idx_prev))]}" 2>/dev/null)" != false ]; do
				(( idx_prev++ ))
				if [ ${idx_prev} -gt ${id_all} ]; then idx_prev=${id_all}; break; fi
			done 2>/dev/null
		fi
		# look for the next older post not draft
		while [ -f "${posts[$((id_all+idx_next))]}" -a "$(header draft < "${posts[$((id_all+idx_next))]}" 2>/dev/null)" != false ]; do
			(( idx_next++ ))
		done 2>/dev/null

		if [ ${idx} -eq 0 -o $((idx_all-idx_prev)) -eq 0 -a ${id_all} -eq 0 ]; then
			POST_PREV="index.html"
		else
			POST_PREV="$( basename "${posts[$((id_all-idx_prev))]}" )"
			POST_PREV="${POST_PREV%*.md}.html"
		fi
		POST_NEXT="$( basename "${posts[$((id_all+idx_next))]}" )"
		[[ -z "${POST_PREV:=}" ]] && POST_PREV='index.html'
		[[ -z "${POST_NEXT:=}" ]] && POST_NEXT='index.md'
		POST_NEXT="${POST_NEXT%*.md}.html"
		# look for the tags
		if [ ${__c:=0} -eq 0 ]; then # When implemented the -c will avoid tags generation
			local _tag=''; TAGSLIST=''
			tags="$(header tags < "$post")"
			if [ ! -z "${tags}" ]; then
				while read _tag; do
					TAGSLIST="${TAGSLIST}${TAGS_LINK//==tagNameSlugged==/$(slug <<< "${_tag}")}"
					TAGSLIST="${TAGSLIST//==tagName==/${_tag}}"
					_allTags="${_allTags//${_tag},/}${_tag},"
				done <<< "$(echo -e "${tags//,/\\n}")"
			fi
		else
			unset TAGSLIST
			unset tags
		fi
		# Render the post
		echo -e "${idx}\t- ${id}\t[${tags}]"
		render_file "$post" > "$OUTPUT_DIR/$id.html" &
		declare "posts_${idx}_id"="$id"
		if [ ${__x:=0} -eq 0 ]; then # RSS datetime has to be RFC 822 compliant
			declare -g "posts_${idx}_rssdate"="$(date -R --date "$(header date < "$post")")"
		fi
		export_headers "$post" "posts_${idx}_"
		POST_PREV="$id.html"
		(( id_all++ ))
		(( idx++ ))
	done
	if [ ${__x:=0} -eq 0 ]; then
		echo "Rendering RSS" >&2
		RSS_DATE="$(date -R)"
		render_file "$LAYOUT_DIR/rss.md" > "$OUTPUT_DIR/rss.xml" &
		wait
	fi
	echo "Rendering Index..." >&2
	render_file "$LAYOUT_DIR/index.md" > "$OUTPUT_DIR/index.html" &
	wait
	# Generate the indexes for each tags
	if [ ${__c:=0} -eq 0 ]; then
		echo "Rendering Index for categories..." >&2
		while read _tagIdx; do
			# It's really important to unset all posts variables
			while read a; do unset "${a}"; done <<< "$(compgen  -v | grep -E "^posts_[0-9]")"
			idx=0
			id_all=0
			for post in "${posts[@]}"; do
				id="$(basename "$post" .md)"
				if [ "$(header draft < "$post")" != false ]; then continue; fi
				tags="$(header tags < "$post")"
				if [ ! -z "${tags}" ]; then
					while read _tag; do
						if [ "${_tag}" = "${_tagIdx}" ] ; then
							declare "posts_${idx}_id"="$id"
							export_headers "$post" "posts_${idx}_"
							(( idx++ ))
						fi
					done <<< "$(echo -e "${tags//,/\\n}")"
				fi
			done
			render_file "$LAYOUT_DIR/index.md" > "$OUTPUT_DIR/index_$(slug <<< "${_tagIdx}").html" &
			wait
		done <<< "$(echo -e "${_allTags//,/\\n}")"
	fi
}

# die print message to stderr and exit
die() {
	echo -e "${@}" >&2
	exit 1
}

#
# usage
#
usage() {
	cat <<-EOF
	### This special version has 2 flavours, the old one : 
	baker 
	  post   [title] draft a post 
	  bake           ship all posts 
	  list           list all posts with state
	  toggle [post]  toggle the draft status of a post
	  date   [title] change the date of a post
	  rename [title] parse the header to re-generate the filename of a post
	### And the new one :
	baker [-p <title>|-b [-t][-x]|-l|-s <title|id>|-d <title|id> [-D]|-r <title|id>] [-f <filename>] [-w <path>] [-h]
	  -b            ship all posts
	  -d [title|id] change the date of a post
	  -D            don't change the filename when changing date
	  -f [file]     get the configuration from a file
	  -h            print help (you currently read it)
	  -l            list all posts with state
	  -n            No default config file loaded BAKER_CONFIG
	  -p "[title]"  draft a post
	  -r [title|id] parse a post content to re-generate the filename
	  -s [title|id] toggle the draft status of a post
	  -t            don't generate tags
	  -w [path]     use this path to work instead of ./
	  -x            don't generate the RSS feed file
	EOF
	exit 1
}

# checkBinaries check the script is able to run and give hints
checkBinaries() {
	local cmdErr="perl sed awk cat basename find date iconv tr dirname readlink column"
	set ${cmdErr}
	while [ ${#} -ne 0 ]; do
		if ! command -v "${1:-}" &>/dev/null; then
			echo "command not found: ${1}" >&2
			local rc=1
		fi
		shift
	done
	[[ ${rc:=0} -ne 0 ]] && die "At least one command is missing. Please install it before using Baker."
}

checkBinaries
(( $# == 0 )) && usage

_regex='^(post|bake|list|toggle|date|rename)$'
if [[ ${1:-} =~ ${_regex} ]]; then
	case "$1" in
		bake) __b=1 ;;
		post) __p=1; __post="${@:2}" ;;
		list) __l=1;;
		toggle) __t=1; __post="${@:2}" ;;
		date) __d=1; __post="${@:2}" ;;
		rename) __r=1; __post="${@:2}" ;;
		*) usage ;;
	esac
else
	# used      : ---b--Dd---f--Hh-------l---n---p---r-s-t-----w-x--------------
	# available : AaB-Cc--EeF-Gg--IiJjKkL-MmN-OoP-QqR-S-T-UuVvW-X-YyZz0123456789
	while getopts ":d:f:p:r:s:w:bDhHlntx" option; do
		case ${option} in
			b) __b=1;;
			c) __c=1;;
			d) __d=1;__post="${OPTARG}";;
			D) __D=1;;
			l) __l=1;;
			f) __f="${OPTARG}";;
			n) __n=1;;
			p) __p=1;__post="${OPTARG}";;
			r) __r=1;__post="${OPTARG}";;
			s) __s=1;__post="${OPTARG}";;
			t) __t=1;;
			w) [[ -d "${OPTARG}" ]] && __w="$( cd ${OPTARG}; pwd)/";;
			x) __x=1;;
			?|H|h) usage; exit 0;;
			*) echo "Argument unknown" >&2; usage;;
		esac
	done
fi

if [ $(( ${__b:=0} + ${__d:=0} + ${__l:=0} + ${__p:=0} + ${__r:=0} + ${__s:=0} )) -gt 1 ]; then
	echo "You have to choose between -b, -d, -l, -p, -r, -s" >&2
	usage
elif [ $(( ${__b:=0} + ${__d:=0} + ${__l:=0} + ${__p:=0} + ${__r:=0} + ${__s:=0} )) -lt 1 ]; then
	echo "Nothing to do ?" >&2
	usage
fi
if [ ! -z "${__w:=}" -a ! -d "${__w}" ]; then
	echo "Working directory doesn't exist !" >&2
	usage
fi
config "${__f:=}"

readonly POST_DIR; readonly OUTPUT_DIR; readonly DRAFT_DIR; readonly LAYOUT_DIR; readonly PUBLIC_DIR
readonly SITE_NAME; readonly SITE_DESC
readonly AUTHOR_NAME; readonly AUTHOR_DESC; readonly AUTHOR_EMAIL; readonly AUTHOR_EMAIL_HASH;
readonly AUTHOR_TWITTER; readonly AUTHOR_GITHUB; readonly DISQUS
readonly TAGS_LINK; readonly TAGS_BASELINK


if [ ${__b} -eq 1 ]; then
	post_bake
elif [ ${__l} -eq 1 ]; then
	post_list
elif [ ${__d} -eq 1 ]; then
	post_date "${__post}"
elif [ ${__p} -eq 1 ]; then
	post_post "${__post}"
elif [ ${__r} -eq 1 ]; then
	post_rename "${__post}"
elif [ ${__s} -eq 1 ]; then
	post_toggle "${__post}"
else
	die "Warp  Zone : Mario was here"
fi
exit 0

